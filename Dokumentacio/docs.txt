Inside The Rebalancing algorithms:
1. Sort the computerlist and save a copy of it based on the resources TOTAL cores.               DONE
    if there are computers with the same amount cores we sort by memory.

2. Sort the programlist and save a copy of it based on their cores taken for them to run.
    if there are programs with the same amount of cores taken to run them we sort by the memory taken to run them.               DONE

a)-----------------------------------A Last Re-sort----------------------------------------- Load Balancing Algo.               DONE

Heuristic Load Balancing
3. Assign a score to all computers based that shows us how well they utalize their resources. (A higher score means the computer is heavily loaded)
4. Assign programs to the lowest scoring computer that can still fit the program. (lowest scoring) (has enough core and memory)
    if no computer can fit the program, move to the next program.
5. Reduce the available resources of the computer accordingly.
6. Update the scores to reflect the changes.
7. Repeat steps 3-7 until all programs are sorted

--- Slowest, Evenly distributes the load leaving no computer overloaded.


b)-----------------------------------No Space Left Behind----------------------------------------- Efficient Packing Algo.

Greedy Best Fit Decreasing
3. Find the best-fitting computer, which is the one with the least remaining resources after placing the program (but still enough to fit the program).
    if no computer can fit it, move to the next program.
4. Assign the program to the computer.
5. Reduce the available resources of the computer accordingly.
6. Repeat steps 3-6 until all programs are sorted.

--- Balanced speed, Doesn`t leave gaps on the computer in resources 


c)-----------------------------------The Fast Lane----------------------------------------- Speed Prioritizing Algo.

First Fit 
3. Iterate through the programs and put the on the first computer they fit on
    if no computer can fit it, move to the next program.
4. Repeat steps 3-4 until all programs are sorted.

--- Fastest, Leads to inefficient packing (best used if the computers are similar in resources)

"""

# On init we save the processes from the .klaszter file to the self.processes dict. and then to global processes 
# Then we create a local holder for both active and inactive processes and sort them
# Sorting the global processes does 2 things:
# - It groups the processes into active and inactive variants
# - And it merges the dictionary with the global active and inactive process dicts. -> We need to do this so that the information about processes survives through re-initializations 
    # If a process already exist in the global dicts we do not put it in the global dicts
# - It makes the local process dicts(ONLY THE ACTIVE AND INACTIVE PROCESS DICTS NOT THE NORMAL PROCESS DICT) the same as the global ones
# 
# Then we format the cluster config file so that we dont get duplicate programs
# And atlast we update the config file to reflect the standing of the local process dicts.


# start_process: ------------ NOT UP TO DATE ASK ME(PETAH) ABOUT IT
#  check if the global processes already have the process
#       if not we put it in the global config and reinicialize. REFERENCE Upper comment for reinicialization process
# 
# kill_process:
#  check if it exists in either global process dicts
#       if not just return
#  if it does we remove it from both the process dict so that it doesnt get written into the global process list AND remove it from the global process list
#  we resort the process (we only do this so that it copies the processes from the global dicts to the local ones)
#  from here REFERENCE Upper comment for reinicialization process